DT.animation={easing:{linear(progress){return progress},swing(progress){return 0.5-Math.cos(progress*Math.PI)/2},},kebabize(str){return str.replace(/[A-Z]+(?![a-z])|[A-Z]/g,(part,ofs)=>(ofs?'-':'')+part.toLowerCase())},AnimateProperty:class{constructor({element,name,initialValue,finalValue,unit='px'}){this.element=element;this.name=name;this.computedName=DT.animation.kebabize(this.name);this.currentValue=0;this.initialValue=initialValue;this.finalValue=finalValue;this.unit=unit}
cleanup(){this.element.style.removeProperty(this.computedName)}
prepare(value){if(value===undefined||value===null)return;this.element.style[this.name]=value+this.unit}
keepValueInBounds(){if(this.currentValue>this.finalValue&&this.currentValue>this.initialValue){if(this.initialValue>this.finalValue){this.currentValue=this.initialValue;return}
this.currentValue=this.finalValue;return}
if(this.currentValue<this.finalValue&&this.currentValue<this.initialValue){if(this.initialValue<this.finalValue){this.currentValue=this.initialValue;return}
this.currentValue=this.finalValue;return}}
animate(progress){this.currentValue=this.initialValue+progress*(this.finalValue-this.initialValue);this.keepValueInBounds();this.element.style[this.name]=this.currentValue+this.unit}},AnimateProperties:class{constructor(properties){this.properties=properties.map((prop)=>new DT.animation.AnimateProperty(prop))}
cleanup(){this.properties.forEach((prop)=>prop.cleanup())}
prepare(value){this.properties.forEach((prop)=>prop.prepare(value))}
animate(progress){this.properties.forEach((prop)=>prop.animate(progress))}},animateCandidateProps:['height','paddingTop','paddingBottom','marginTop','marginBottom',],cleanup(element){element.style.removeProperty('overflow')},getPropsToAnimate(element){animateProps=[];this.animateCandidateProps.forEach((name)=>{const value=parseFloat(window.getComputedStyle(element).getPropertyValue(this.kebabize(name)));if(!value)return;animateProps.push({name,value,})});return animateProps},animate({element,prepareValue=null,animateProps,easing,duration}){return new Promise((resolve)=>{animateProps.prepare(prepareValue);const frameTimeMs=16;const frames=Math.ceil(duration/frameTimeMs);let currentFrame=0;const tick=()=>{currentFrame++;const progress=easing(currentFrame/frames);animateProps.animate(progress);if(currentFrame<frames)return DT.onNextFrame(tick);animateProps.cleanup();this.cleanup(element);resolve()};DT.onNextFrame(tick)})},async slideUp(element,duration=200,options={}){const display=window.getComputedStyle(element).display;if(display==='none')return;if(typeof options!=='object'){options={}}
let animateOptions=Object.assign({},{easing:'swing'},options);const easing=this.easing[animateOptions.easing];element.style.height=element.offsetHeight+'px';element.style.overflow='hidden';const propsToAnimate=this.getPropsToAnimate(element);if(!propsToAnimate.length)return;const animateProps=new this.AnimateProperties(propsToAnimate.map(({name,value})=>{return{element,name,initialValue:value,finalValue:0,}}));await this.animate({animateProps,easing,duration,element,});element.style.display='none'},async slideDown(element,duration=200,afterDisplay='flex'){const defaultOptions={afterDisplay:'flex',easing:'swing',};let animateOptions;if(typeof afterDisplay==='string'){animateOptions=Object.assign({},defaultOptions,{afterDisplay})}else{animateOptions=Object.assign({},defaultOptions,afterDisplay)}
const easing=this.easing[animateOptions.easing];element.style.removeProperty('display');let display=window.getComputedStyle(element).display;if(display==='none')display=animateOptions.afterDisplay;element.style.display=display;element.style.overflow='hidden';const propsToAnimate=this.getPropsToAnimate(element);if(!propsToAnimate.length)return;const animateProps=new this.AnimateProperties(propsToAnimate.map(({name,value})=>{return{element,name,initialValue:0,finalValue:value,}}));await this.animate({prepareValue:'0',animateProps,easing,duration,element,})},slideToggle(element,duration=200,afterDisplay='flex'){const display=window.getComputedStyle(element).display;if(display==='none'){return this.slideDown(element,duration,afterDisplay)}
return this.slideUp(element,duration,afterDisplay)},async fadeOut(element,duration=400){const animateProps=new this.AnimateProperties([{element,name:'opacity',initialValue:1,finalValue:0,unit:'',},]);await this.animate({animateProps,easing:this.easing.linear,duration,element,});element.style.display='none'},fadeIn(element,duration=400){if(window.getComputedStyle(element).display==='none'){element.style.removeProperty('display')}
const animateProps=new this.AnimateProperties([{element,name:'opacity',initialValue:0,finalValue:1,unit:'',},]);return this.animate({animateProps,easing:this.easing.linear,prepareValue:0,duration,element,})},scrollSmoothTo(element,duration=400,{center=!0,offset=0,scrollIfInView=!1}={}){return new Promise(async(resolve)=>{const easeInOutQuad=(time,start,distance,duration)=>{time/=duration/2;if(time<1)return(distance/2)*time*time+start;time--;return(-distance/2)*(time*(time-2)-1)+start};try{await DT.loadScriptsOnce('templates/get_header_offset.js')}catch(err){DT.log('error',err)}
const scrollTop=window.pageYOffset;const headerOffset=DT.getHeaderOffset?DT.getHeaderOffset():0;const elementOffsetTop=DT.UI.offset(element).top+offset-headerOffset;const windowHeight=window.innerHeight;const isInView=elementOffsetTop>scrollTop&&elementOffsetTop<scrollTop+windowHeight;if(!scrollIfInView&&isInView){resolve();return}
const start=window.scrollY;let startTime=null;let distance=elementOffsetTop-start;if(center)distance-=Math.round(windowHeight/3);const tick=(currentTime)=>{if(startTime===null){startTime=currentTime}
const timeElapsed=currentTime-startTime;const scrollPosition=easeInOutQuad(timeElapsed,start,distance,duration);window.scrollTo(0,scrollPosition);if(timeElapsed<duration){DT.onNextFrame(tick);return}
resolve()};DT.onNextFrame(tick)})},}